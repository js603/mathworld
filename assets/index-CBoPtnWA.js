var M=Object.defineProperty;var P=(l,t,e)=>t in l?M(l,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):l[t]=e;var T=(l,t)=>()=>(t||l((t={exports:{}}).exports,t),t.exports);var c=(l,t,e)=>P(l,typeof t!="symbol"?t+"":t,e);var et=T((it,k)=>{(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const a of i)if(a.type==="childList")for(const r of a.addedNodes)r.tagName==="LINK"&&r.rel==="modulepreload"&&s(r)}).observe(document,{childList:!0,subtree:!0});function e(i){const a={};return i.integrity&&(a.integrity=i.integrity),i.referrerPolicy&&(a.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?a.credentials="include":i.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(i){if(i.ep)return;i.ep=!0;const a=e(i);fetch(i.href,a)}})();const _={trust:0,fear:0,respect:0,debt:0,secretShared:!1,history:[]};class L{constructor(){c(this,"edges",new Map)}getRelation(t,e){this.edges.has(t)||this.edges.set(t,new Map);const s=this.edges.get(t);return s.has(e)||s.set(e,{..._}),s.get(e)}updateRelation(t,e,s){const i=this.getRelation(t,e);Object.assign(i,s),i.trust=Math.max(-1,Math.min(1,i.trust)),i.fear=Math.max(0,Math.min(1,i.fear)),i.respect=Math.max(-1,Math.min(1,i.respect))}modifyRelation(t,e,s){const i=this.getRelation(t,e);s.trust!==void 0&&(i.trust+=s.trust),s.fear!==void 0&&(i.fear+=s.fear),s.respect!==void 0&&(i.respect+=s.respect),s.debt!==void 0&&(i.debt+=s.debt),s.secretShared!==void 0&&(i.secretShared=s.secretShared),i.trust=Math.max(-1,Math.min(1,i.trust)),i.fear=Math.max(0,Math.min(1,i.fear)),i.respect=Math.max(-1,Math.min(1,i.respect))}addHistory(t,e,s){this.getRelation(t,e).history.push(s)}getMutualFriends(t,e){const s=this.getFriends(t),i=this.getFriends(e);return s.filter(a=>i.includes(a))}getFriends(t){const e=[],s=this.edges.get(t);if(s)for(const[i,a]of s)a.trust>0&&e.push(i);return e}getEnemies(t){const e=[],s=this.edges.get(t);if(s)for(const[i,a]of s)a.trust<-.3&&e.push(i);return e}getClusters(t=.3){const e=new Set;for(const[a,r]of this.edges){e.add(a);for(const n of r.keys())e.add(n)}const s=new Set,i=[];for(const a of e){if(s.has(a))continue;const r=[],n=[a];for(;n.length>0;){const o=n.shift();if(s.has(o))continue;s.add(o),r.push(o);const h=this.getFriends(o);for(const u of h)this.getRelation(u,o).trust>t&&!s.has(u)&&n.push(u)}r.length>1&&i.push(r)}return i}getCentrality(t){let e=0;const s=this.edges.get(t);s&&(e+=s.size);for(const[,i]of this.edges)i.has(t)&&(e+=1);return e}getRelationHeat(t,e){const s=this.getRelation(t,e);return s.trust+s.respect*.5-s.fear*.3}getMostInfluential(t=5){const e=new Set;for(const[i,a]of this.edges){e.add(i);for(const r of a.keys())e.add(r)}const s=Array.from(e).map(i=>({id:i,centrality:this.getCentrality(i)}));return s.sort((i,a)=>a.centrality-i.centrality),s.slice(0,t).map(i=>i.id)}simulateRumorSpread(t,e,s){const i=new Set([t]),a=new Set([t]);for(let r=0;r<e;r++){const n=new Set;for(const o of a){const h=this.edges.get(o);if(h)for(const[u,d]of h){if(i.has(u))continue;const E=s(d);Math.random()<E&&(n.add(u),i.add(u))}}a.clear();for(const o of n)a.add(o)}return i}getStats(){let t=0,e=0,s=0,i=0;const a=new Set;for(const[r,n]of this.edges){a.add(r);for(const[o,h]of n)a.add(o),e++,s+=h.trust,i+=h.fear}return t=a.size,{nodeCount:t,edgeCount:e,avgTrust:e>0?s/e:0,avgFear:e>0?i/e:0}}}class A{constructor(){c(this,"_time",0);c(this,"_characters",new Map);c(this,"_locations",new Map);c(this,"_relations");c(this,"_history",[]);c(this,"_globalState");this._relations=new L,this._globalState={warActive:!1,economyIndex:1,plagueActive:!1,season:"spring",dayOfYear:1}}get time(){return this._time}get globalState(){return{...this._globalState}}get relations(){return this._relations}advanceTime(){this._time++,this._globalState.dayOfYear++,this._globalState.dayOfYear>365&&(this._globalState.dayOfYear=1);const t=this._globalState.dayOfYear;t<=90?this._globalState.season="spring":t<=180?this._globalState.season="summer":t<=270?this._globalState.season="autumn":this._globalState.season="winter",this.applyEmotionDecay()}applyEmotionDecay(){for(const e of this._characters.values())e.emotion.anger*=.95,e.emotion.fear*=.95,e.emotion.joy*=.95,e.emotion.despair*=.95}addCharacter(t){this._characters.set(t.id,t)}getCharacter(t){return this._characters.get(t)}getAllCharacters(){return Array.from(this._characters.values())}getCharactersAt(t){return this.getAllCharacters().filter(e=>e.location===t)}updateCharacter(t,e){const s=this._characters.get(t);s&&Object.assign(s,e)}addLocation(t){this._locations.set(t.id,t)}getLocation(t){return this._locations.get(t)}getAllLocations(){return Array.from(this._locations.values())}addEvent(t){this._history.push(t);for(const e of t.witnesses){const s=this._characters.get(e);s&&s.memory.push({eventId:t.id,interpretation:t.description,emotionalImpact:{},timestamp:this._time})}}getRecentEvents(t=10){return this._history.slice(-t)}getEventsByParticipant(t){return this._history.filter(e=>e.participants.includes(t))}applyEffect(t){switch(t.type){case"emotion":this.applyEmotionEffect(t);break;case"relation":this.applyRelationEffect(t);break;case"resource":this.applyResourceEffect(t);break;case"stat":this.applyStatEffect(t);break}}applyEmotionEffect(t){const e=this._characters.get(t.target);if(!e)return;const s=t.field;s in e.emotion&&(t.isRelative?e.emotion[s]+=t.change:e.emotion[s]=t.change,e.emotion[s]=Math.max(0,Math.min(1,e.emotion[s])))}applyRelationEffect(t){const[e,s]=t.target.split(":"),i=this._relations.getRelation(e,s);if(!i)return;const a=t.field;a in i&&typeof i[a]=="number"&&(t.isRelative?i[a]+=t.change:i[a]=t.change),this._relations.updateRelation(e,s,i)}applyResourceEffect(t){const e=this._characters.get(t.target);e&&(t.isRelative?e.resources+=t.change:e.resources=t.change)}applyStatEffect(t){const e=this._characters.get(t.target);e&&t.field==="power"&&(t.isRelative?e.power+=t.change:e.power=t.change)}updateGlobalState(t){Object.assign(this._globalState,t)}snapshot(){return{time:this._time,characterCount:this._characters.size,locationCount:this._locations.size,historyLength:this._history.length,globalState:this._globalState}}}function y(l,t,e){return Math.max(t,Math.min(e,l))}function R(l,t,e){return l+(t-l)*e}function I(l){return 1/(1+Math.exp(-l))}function f(l="id"){return`${l}_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}function p(l,t){return l+Math.random()*(t-l)}function m(l){if(l.length!==0)return l[Math.floor(Math.random()*l.length)]}function b(l){return Math.random()<l}const B={ambition:.5,loyalty:.5,morality:.5,courage:.5,cunning:.5},D={trust:.5,fear:0,anger:0,joy:.3,despair:0};function S(l){return{id:f("char"),name:l.name,title:l.title,personality:{...B,...l.personality},emotion:{...D,...l.emotion},location:l.location,resources:l.resources??100,power:l.power??10,memory:[],beliefs:new Map,isPlayer:l.isPlayer??!1}}const v={updateEmotion(l,t){for(const[e,s]of Object.entries(t)){const i=e;l.emotion[i]=Math.max(0,Math.min(1,l.emotion[i]+s))}},addMemory(l,t,e,s,i){l.memory.push({eventId:t,interpretation:e,emotionalImpact:s,timestamp:i}),this.updateEmotion(l,s)},updateBelief(l,t,e,s=.1){const i=l.beliefs.get(t)??.5,a=i+e*s*(1-Math.abs(i-.5)*2);l.beliefs.set(t,Math.max(0,Math.min(1,a)))},beliefKey(l,t){return`${l}:${t}`},getDominantEmotion(l){const t=l.emotion;let e="trust",s=0;for(const[i,a]of Object.entries(t))a>s&&(s=a,e=i);return e},getBehaviorTendency(l){const{personality:t,emotion:e}=l;return{aggressive:t.ambition*.3+t.courage*.3+e.anger*.4-(t.morality*.2+e.fear*.2),cooperative:t.loyalty*.3+t.morality*.3+e.trust*.4-e.anger*.2,cautious:e.fear*.4+(1-t.courage)*.3+t.cunning*.3}},getMemoriesAbout(l,t,e=5){return l.memory.filter(s=>s.interpretation.includes(t)).slice(-e)}},C={noble:{ambition:.7,loyalty:.6,morality:.6,courage:.7,cunning:.5},merchant:{ambition:.8,loyalty:.4,morality:.5,courage:.3,cunning:.8}};class F{constructor(t){c(this,"world");this.world=t}calculateUtility(t,e,s){if(!this.checkConditions(t,e.conditions,s))return{action:e,utility:-1/0,breakdown:{selfBenefit:0,targetBenefit:0,risk:0,personalityFit:0,emotionalFit:0}};const i=this.calculateSelfBenefit(t,e.effects),a=s?this.calculateTargetBenefit(t,s,e.effects):0,n=(1-this.calculateSuccessRate(t,e,s))*e.weights.riskFactor,o=this.calculatePersonalityFit(t,e),h=this.calculateEmotionalFit(t,e),u=i*e.weights.selfBenefit+a*e.weights.targetBenefit-n+o*.3+h*.2;return{action:e,utility:u,breakdown:{selfBenefit:i,targetBenefit:a,risk:n,personalityFit:o,emotionalFit:h}}}selectAction(t,e,s){if(e.length===0)return null;const a=e.map(u=>this.calculateUtility(t,u,s)).filter(u=>u.utility>-1/0);if(a.length===0)return null;a.sort((u,d)=>d.utility-u.utility);const r=a.slice(0,Math.min(3,a.length)),n=r.map(u=>Math.max(.1,I(u.utility))),o=n.reduce((u,d)=>u+d,0);let h=Math.random()*o;for(let u=0;u<r.length;u++)if(h-=n[u],h<=0)return{action:r[u].action,result:r[u]};return{action:r[0].action,result:r[0]}}checkConditions(t,e,s){for(const i of e)if(!this.checkCondition(t,i,s))return!1;return!0}checkCondition(t,e,s){let i;switch(e.type){case"stat":i=this.getStatValue(t,e.field);break;case"relation":if(!s)return!1;i=this.getRelationValue(t.id,s,e.field);break;case"resource":i=t.resources;break;case"location":i=t.location;break;default:return!0}return this.compareValues(i,e.operator,e.value)}getStatValue(t,e){return e in t.personality?t.personality[e]:e in t.emotion?t.emotion[e]:e==="power"?t.power:e==="resources"?t.resources:0}getRelationValue(t,e,s){const i=this.world.relations.getRelation(t,e);return s in i?i[s]:0}compareValues(t,e,s){switch(e){case">":return t>s;case"<":return t<s;case">=":return t>=s;case"<=":return t<=s;case"==":return t===s;case"!=":return t!==s;default:return!1}}calculateSelfBenefit(t,e){let s=0;for(const i of e)if(i.target===t.id||i.target==="self")switch(i.type){case"resource":s+=i.change*.01;break;case"stat":i.field==="power"&&(s+=i.change*.1);break;case"emotion":i.field==="joy"&&(s+=i.change),i.field==="fear"&&(s-=i.change);break}return s}calculateTargetBenefit(t,e,s){const i=this.world.relations.getRelation(t.id,e);let a=0;for(const r of s)if(r.target===e||r.target==="target")switch(r.type){case"resource":a+=r.change*.01;break;case"emotion":r.field==="fear"&&(a-=r.change);break}return a*i.trust}calculateSuccessRate(t,e,s){let i=e.baseSuccessRate;switch(e.category){case"dialogue":i*=.5+t.personality.cunning*.5;break;case"combat":i*=.5+t.personality.courage*.5;break;case"social":if(s){const a=this.world.relations.getRelation(t.id,s);i*=.5+(a.trust+1)*.25}break}return y(i,0,1)}calculatePersonalityFit(t,e){const s=t.personality;let i=0;switch(e.category){case"combat":i=s.courage*.5+s.ambition*.3-s.morality*.2;break;case"dialogue":i=s.cunning*.4+s.loyalty*.3;break;case"social":i=s.loyalty*.4+s.morality*.3;break;case"economic":i=s.ambition*.5+s.cunning*.3;break}return i}calculateEmotionalFit(t,e){const s=t.emotion;let i=0;return e.category==="combat"&&(i+=s.anger*.5),s.fear>.5&&e.category!=="combat"&&(i+=.3),(e.category==="social"||e.category==="dialogue")&&(i+=s.trust*.3),i}}const N=[{id:"talk_friendly",name:"우호적 대화",category:"dialogue",conditions:[],effects:[{type:"relation",target:"self:target",field:"trust",change:.05,isRelative:!0}],baseSuccessRate:.9,weights:{selfBenefit:.3,targetBenefit:.5,riskFactor:.1}},{id:"threaten",name:"위협",category:"dialogue",conditions:[{type:"stat",field:"power",operator:">=",value:5}],effects:[{type:"relation",target:"self:target",field:"fear",change:.2,isRelative:!0},{type:"relation",target:"self:target",field:"trust",change:-.1,isRelative:!0}],baseSuccessRate:.7,weights:{selfBenefit:.7,targetBenefit:-.5,riskFactor:.5}},{id:"trade",name:"거래",category:"economic",conditions:[{type:"resource",operator:">=",value:10}],effects:[{type:"resource",target:"self",field:"resources",change:-10,isRelative:!0},{type:"relation",target:"self:target",field:"trust",change:.03,isRelative:!0}],baseSuccessRate:.95,weights:{selfBenefit:.4,targetBenefit:.4,riskFactor:.2}},{id:"attack",name:"공격",category:"combat",conditions:[],effects:[{type:"relation",target:"self:target",field:"trust",change:-.5,isRelative:!0},{type:"relation",target:"self:target",field:"fear",change:.3,isRelative:!0}],baseSuccessRate:.6,weights:{selfBenefit:.8,targetBenefit:-1,riskFactor:.8}},{id:"help",name:"도움 제공",category:"social",conditions:[{type:"resource",operator:">=",value:20}],effects:[{type:"resource",target:"self",field:"resources",change:-20,isRelative:!0},{type:"relation",target:"self:target",field:"trust",change:.15,isRelative:!0},{type:"relation",target:"self:target",field:"debt",change:20,isRelative:!0}],baseSuccessRate:1,weights:{selfBenefit:.2,targetBenefit:.8,riskFactor:.1}},{id:"betray",name:"배신",category:"social",conditions:[{type:"relation",field:"trust",operator:">",value:0}],effects:[{type:"resource",target:"self",field:"resources",change:50,isRelative:!0},{type:"relation",target:"self:target",field:"trust",change:-.8,isRelative:!0}],baseSuccessRate:.5,weights:{selfBenefit:1,targetBenefit:-1,riskFactor:1}}];class O{constructor(t,e){c(this,"world");c(this,"utilityAI");c(this,"actionPool");this.world=t,this.utilityAI=new F(t),this.actionPool=[...N,...e||[]]}generateChoices(t,e,s=4){const i=this.actionPool.map(n=>({action:n,result:this.utilityAI.calculateUtility(t,n,e)})).filter(n=>n.result.utility>-1/0);i.sort((n,o)=>o.result.utility-n.result.utility);const a=[],r=new Set;for(const n of i){if(a.length>=s)break;const o=n.action.category;if(!r.has(o)||a.length<s/2){const h=this.determineContext(t,e,n.action);a.push(this.createChoice(n.action,h,n.result.utility)),r.add(o)}}return a.map(n=>this.contextualizeChoice(n,t,e))}createChoice(t,e,s){return{id:f("choice"),text:this.generateChoiceText(t,e),action:t,context:this.getContextDescription(e),calculatedUtility:s}}generateChoiceText(t,e){const s=this.getContextPrefix(e);switch(t.id){case"talk_friendly":return`${s}친근하게 대화한다`;case"threaten":return`${s}위협한다`;case"trade":return`${s}거래를 제안한다`;case"attack":return`${s}공격한다`;case"help":return`${s}도움을 제공한다`;case"betray":return`${s}배신한다`;default:return`${s}${t.name}`}}getContextPrefix(t){switch(t){case"respectful":return"[정중하게] ";case"suspicious":return"[경계하며] ";case"fearful":return"[두려움을 느끼며] ";case"confident":return"[자신감 있게] ";case"desperate":return"[절박하게] ";default:return""}}getContextDescription(t){switch(t){case"respectful":return"상대가 당신을 존중하고 있다";case"suspicious":return"상대가 당신을 의심하고 있다";case"fearful":return"상대가 당신을 두려워하고 있다";case"confident":return"당신이 우위에 있다";case"desperate":return"상황이 불리하다";default:return"평범한 상황이다"}}determineContext(t,e,s){if(!e)return"neutral";const i=this.world.relations.getRelation(e,t.id);this.world.relations.getRelation(t.id,e);const a=this.world.getCharacter(e);return i.fear>.5?"fearful":i.trust<-.3?"suspicious":i.respect>.5?"respectful":a&&t.power>a.power*1.5?"confident":a&&t.power<a.power*.5?"desperate":"neutral"}contextualizeChoice(t,e,s){if(!s)return t;const i=this.world.relations.getRelation(e.id,s);return this.world.getCharacter(s)?(i.history.length,t.action.id==="talk_friendly"&&i.trust<0?{...t,context:"과거의 상처가 남아있다. 그래도 대화를 시도할 것인가?",text:"[조심스럽게] 대화를 시도한다"}:t.action.id==="help"&&i.debt<0?{...t,context:"당신은 이 사람에게 빚이 있다",text:"[빚을 갚기 위해] 도움을 제공한다"}:i.secretShared&&t.action.category==="dialogue"?{...t,context:"당신들은 비밀을 공유하고 있다"}:t):t}generateSpecialChoices(t,e){const s=[];switch(e){case"combat":s.push({id:"flee",name:"도주",category:"combat",conditions:[],effects:[],baseSuccessRate:.7,weights:{selfBenefit:.5,targetBenefit:0,riskFactor:.3}}),s.push({id:"surrender",name:"항복",category:"combat",conditions:[],effects:[{type:"relation",target:"self:target",field:"fear",change:.3,isRelative:!0}],baseSuccessRate:1,weights:{selfBenefit:-.5,targetBenefit:.5,riskFactor:0}});break;case"negotiation":s.push({id:"bluff",name:"허세",category:"dialogue",conditions:[],effects:[],baseSuccessRate:.4,weights:{selfBenefit:.6,targetBenefit:-.2,riskFactor:.6}}),s.push({id:"compromise",name:"타협",category:"social",conditions:[],effects:[{type:"relation",target:"self:target",field:"trust",change:.1,isRelative:!0}],baseSuccessRate:.8,weights:{selfBenefit:.3,targetBenefit:.3,riskFactor:.1}});break;case"crisis":s.push({id:"sacrifice",name:"희생",category:"social",conditions:[],effects:[{type:"resource",target:"self",field:"resources",change:-50,isRelative:!0}],baseSuccessRate:1,weights:{selfBenefit:-1,targetBenefit:1,riskFactor:0}});break}return s.map(i=>({id:f("choice"),text:i.name,action:i,context:e}))}getSilenceChoice(){return{id:f("choice"),text:"[침묵을 지킨다]",action:{id:"silence",name:"침묵",category:"dialogue",conditions:[],effects:[],baseSuccessRate:1,weights:{selfBenefit:0,targetBenefit:0,riskFactor:0}},context:"아무 말도 하지 않는다"}}getObserveChoice(){return{id:f("choice"),text:"[상황을 관찰한다]",action:{id:"observe",name:"관찰",category:"dialogue",conditions:[],effects:[],baseSuccessRate:1,weights:{selfBenefit:.1,targetBenefit:0,riskFactor:0}},context:"주변을 살피며 정보를 수집한다"}}}function x(){const l=new A;l.addLocation({id:"capital",name:"왕도",type:"city",resources:1e3,population:5e4,stability:.8,connectedTo:["village1","castle"],owner:"king"}),l.addLocation({id:"village1",name:"변방 마을",type:"village",resources:200,population:500,stability:.6,connectedTo:["capital","wilderness"]});const t=S({name:"왕",title:"아르테미스 왕",location:"capital",personality:C.noble,power:100,resources:1e4}),e=S({name:"마르코",title:"대상인",location:"capital",personality:C.merchant,power:30,resources:5e3}),s=S({name:"모험가",location:"village1",isPlayer:!0,power:10,resources:100});return l.addCharacter(t),l.addCharacter(e),l.addCharacter(s),l.relations.updateRelation(t.id,e.id,{trust:.3,respect:.2}),l.relations.updateRelation(e.id,t.id,{trust:.2,fear:.3}),{world:l,player:s,king:t,merchant:e}}if(typeof require<"u"&&typeof k<"u"&&require.main===k){console.log("MathWorld 엔진 초기화...");const{world:l,player:t}=x();console.log("세계 상태:",l.snapshot()),console.log("플레이어:",t.name)}class W{constructor(t){c(this,"world");c(this,"accumulatedChanges",new Map);c(this,"thresholds",[]);c(this,"pendingEvents",[]);this.world=t,this.initializeThresholds()}initializeThresholds(){this.thresholds=[{id:"trust_collapse",name:"신뢰 붕괴",check:t=>t.relations.getStats().avgTrust<-.3,eventType:"betrayal",description:"전반적인 신뢰가 무너졌다"},{id:"fear_spike",name:"공포 급등",check:t=>t.relations.getStats().avgFear>.6,eventType:"custom",description:"공포가 사회를 지배하고 있다"},{id:"power_vacuum",name:"권력 공백",check:t=>{const e=t.relations.getMostInfluential(1);if(e.length===0)return!1;const s=t.getCharacter(e[0]);return s?s.power<20:!1},eventType:"custom",description:"권력의 공백이 생겼다"}]}applyChoice(t,e,s){const i=this.world.getCharacter(e);if(!i)return;for(const r of t.action.effects)this.applyEffectSilently(r,e,s);const a={id:f("event"),type:this.getEventType(t.action.category),timestamp:this.world.time,participants:s?[e,s]:[e],location:i.location,description:`${i.name}이(가) ${t.text}`,effects:t.action.effects,isPublic:this.isPublicAction(t.action.category),witnesses:this.getWitnesses(i.location,e)};this.world.addEvent(a),this.propagateEffects(a)}applyEffectSilently(t,e,s){let i=t.target;t.target==="self"&&(i=e),t.target==="target"&&s&&(i=s),t.target==="self:target"&&s&&(i=`${e}:${s}`);const a={...t,target:i};this.world.applyEffect(a),this.trackChange(i,t.field,t.change)}trackChange(t,e,s){const i=`${t}:${e}`,a=this.accumulatedChanges.get(i);a?(a.totalChange+=s,a.changeCount++,a.lastTimestamp=this.world.time):this.accumulatedChanges.set(i,{characterId:t,field:e,totalChange:s,changeCount:1,lastTimestamp:this.world.time})}propagateEffects(t){for(const e of t.witnesses)if(!(t.participants.includes(e)||!this.world.getCharacter(e)))for(const i of t.participants)this.evaluateWitnessedAction(e,i,t);t.isPublic&&this.spreadInformation(t)}evaluateWitnessedAction(t,e,s){const i=this.world.getCharacter(t);if(!i)return;let a=0,r=0;switch(s.type){case"betrayal":a=-.2,r=-.1;break;case"combat":i.personality.morality>.6&&(a=-.1),i.personality.courage>.6&&(r=.05);break;case"trade":a=.02;break}(a!==0||r!==0)&&this.world.relations.modifyRelation(t,e,{trust:a,respect:r})}spreadInformation(t){const e=t.participants[0],s=this.world.relations.simulateRumorSpread(e,2,i=>.2+i.trust*.3);for(const i of s){if(t.participants.includes(i))continue;const a=this.world.getCharacter(i);a&&a.memory.push({eventId:t.id,interpretation:`소문: ${t.description}`,emotionalImpact:{},timestamp:this.world.time})}}checkThresholds(){const t=[];for(const e of this.thresholds)if(e.check(this.world)){const s={id:f("event"),type:e.eventType,timestamp:this.world.time,participants:[],location:"global",description:e.description,effects:[],isPublic:!0,witnesses:[]};t.push(s),this.world.addEvent(s)}return t}detectInstability(){const t=[],e=this.world.relations.getStats(),s=this.world.relations.getMostInfluential(2);if(s.length>=2){const i=this.world.getCharacter(s[0]),a=this.world.getCharacter(s[1]);i&&a&&i.power>a.power*2&&t.push("power_imbalance")}return e.avgTrust<-.2&&t.push("trust_collapse"),e.avgFear>.5&&t.push("fear_spike"),t}getAccumulatedChangeSummary(t){const e=[];for(const[s,i]of this.accumulatedChanges)s.startsWith(t)&&(i.field==="trust"&&Math.abs(i.totalChange)>.1&&(i.totalChange>0?e.push("주변 사람들이 당신을 더 신뢰하게 되었다"):e.push("사람들의 시선이 차가워졌다")),i.field==="fear"&&i.totalChange>.1&&e.push("두려움의 그림자가 드리워졌다"),i.field==="respect"&&Math.abs(i.totalChange)>.1&&(i.totalChange>0?e.push("당신의 행동이 존경을 얻었다"):e.push("당신의 명성이 실추되었다")));return e}resetAccumulatedChanges(){this.accumulatedChanges.clear()}getEventType(t){switch(t){case"combat":return"combat";case"economic":return"trade";case"social":return"dialogue";default:return"custom"}}isPublicAction(t){return t==="combat"||t==="economic"}getWitnesses(t,e){return this.world.getCharactersAt(t).filter(s=>s.id!==e).slice(0,5).map(s=>s.id)}}class H{constructor(t){c(this,"world");c(this,"triggers",[]);c(this,"recentEvents",new Set);this.world=t,this.initializeTriggers()}initializeTriggers(){this.triggers.push({id:"power_challenge",name:"권력 도전",condition:t=>{const e=t.relations.getMostInfluential(2);if(e.length<2)return!1;const s=t.getCharacter(e[0]),i=t.getCharacter(e[1]);return!s||!i?!1:i.power>=s.power*.7},baseProbability:.1,probabilityModifiers:[t=>{const e=t.relations.getMostInfluential(2);if(e.length<2)return 0;const s=t.getCharacter(e[1]);return s?s.personality.ambition*.2:0}],generateEvent:t=>{const e=t.relations.getMostInfluential(2),s=t.getCharacter(e[1]);return{id:f("event"),type:"custom",timestamp:t.time,participants:e,location:"capital",description:`${(s==null?void 0:s.name)||"누군가"}가 권력에 도전장을 던졌다`,effects:[],isPublic:!0,witnesses:[]}}}),this.triggers.push({id:"betrayal_plot",name:"배신 음모",condition:t=>t.getAllCharacters().some(s=>s.personality.ambition>.7&&s.personality.loyalty<.3&&s.power>20),baseProbability:.05,probabilityModifiers:[t=>t.relations.getStats().avgTrust<0?.1:0],generateEvent:t=>{const s=t.getAllCharacters().find(i=>i.personality.ambition>.7&&i.personality.loyalty<.3);return{id:f("event"),type:"betrayal",timestamp:t.time,participants:s?[s.id]:[],location:(s==null?void 0:s.location)||"unknown",description:"어둠 속에서 음모가 꿈틀거린다",effects:[],isPublic:!1,witnesses:[]}}}),this.triggers.push({id:"alliance_formation",name:"동맹 형성",condition:t=>t.relations.getClusters(.4).some(s=>s.length>=2),baseProbability:.15,probabilityModifiers:[],generateEvent:t=>{const s=t.relations.getClusters(.4).sort((i,a)=>a.length-i.length)[0];return{id:f("event"),type:"alliance",timestamp:t.time,participants:s||[],location:"capital",description:"새로운 동맹이 결성되었다는 소문이 퍼진다",effects:[],isPublic:!0,witnesses:[]}}}),this.triggers.push({id:"economic_crisis",name:"경제 위기",condition:t=>t.globalState.economyIndex<.7,baseProbability:.2,probabilityModifiers:[t=>(1-t.globalState.economyIndex)*.3],generateEvent:t=>({id:f("event"),type:"custom",timestamp:t.time,participants:[],location:"global",description:"시장이 흔들리고 있다. 물가가 불안정하다.",effects:[],isPublic:!0,witnesses:[]})}),this.triggers.push({id:"scandal",name:"스캔들",condition:t=>t.getAllCharacters().some(s=>s.power>30&&t.relations.getEnemies(s.id).length>0),baseProbability:.08,probabilityModifiers:[],generateEvent:t=>{const s=t.getAllCharacters().find(i=>i.power>30&&t.relations.getEnemies(i.id).length>0);return{id:f("event"),type:"custom",timestamp:t.time,participants:s?[s.id]:[],location:"capital",description:"누군가의 비밀이 새어나가고 있다",effects:[],isPublic:!0,witnesses:[]}}})}detectInstability(){const t=[],e=this.world.relations.getStats(),s=this.world.relations.getMostInfluential(2);if(s.length>=2){const n=this.world.getCharacter(s[0]),o=this.world.getCharacter(s[1]);n&&o&&n.power>o.power*2&&t.push("power_imbalance")}const i=this.world.getAllCharacters();return i.reduce((n,o)=>n+o.resources,0)/i.length<50&&t.push("resource_scarcity"),e.avgTrust<-.2&&t.push("trust_collapse"),this.world.relations.getClusters(.3).length>2&&t.push("information_asymmetry"),e.avgFear>.5&&t.push("fear_spike"),t}generateEvents(){const t=[],e=this.detectInstability();for(const s of this.triggers){if(!s.condition(this.world)||this.recentEvents.has(s.id))continue;let i=s.baseProbability;for(const a of s.probabilityModifiers)i+=a(this.world);if(i=y(i,0,.8),e.length>0&&(i*=1+e.length*.1),b(i)){const a=s.generateEvent(this.world);t.push(a),this.world.addEvent(a),this.recentEvents.add(s.id),setTimeout(()=>this.recentEvents.delete(s.id),0)}}return t}forceEvent(t,e){const s={id:f("event"),type:t,timestamp:this.world.time,participants:e,location:"capital",description:this.getEventDescription(t),effects:[],isPublic:!0,witnesses:[]};return this.world.addEvent(s),s}getEventDescription(t){switch(t){case"war_declared":return"전쟁의 북소리가 울려 퍼진다";case"plague":return"역병의 그림자가 드리운다";case"natural_disaster":return"자연이 분노했다";case"betrayal":return"누군가의 칼이 등을 향했다";case"alliance":return"손이 맞잡혔다";case"death":return"한 생이 저물었다";default:return"무언가가 변했다"}}generateNPCActions(){const t=this.world.getAllCharacters().filter(e=>!e.isPlayer);for(const e of t)if(b(.1)&&(e.personality.ambition>.7&&(e.power+=1),e.personality.cunning>.7&&b(.3))){const s=t.filter(a=>a.id!==e.id),i=m(s);i&&this.world.relations.modifyRelation(e.id,i.id,{trust:.05})}}clearRecentEvents(){this.recentEvents.clear()}}class G{constructor(t){c(this,"world");this.world=t}interpretEvent(t,e,s){const i=this.determineBias(t,e),a=this.generateInterpretation(e,i,s),r=this.calculateEmotionalImpact(t,e,i);return{eventId:e.id,interpretation:a,emotionalImpact:r,timestamp:this.world.time}}determineBias(t,e){const s=e.participants.map(a=>({id:a,relation:this.world.relations.getRelation(t.id,a)})),i=s.reduce((a,r)=>a+r.relation.trust,0)/Math.max(1,s.length);return t.emotion.fear>.5?"fearful":t.emotion.anger>.5?"negative":i<-.3?"suspicious":i>.3?"positive":"neutral"}generateInterpretation(t,e,s){const i=s?"":"소문에 의하면, ";let a=t.description;switch(e){case"positive":a=`${i}${t.description} (좋은 의도였을 것이다)`;break;case"negative":a=`${i}${t.description} (분명 불순한 의도가 있다)`;break;case"suspicious":a=`${i}${t.description} (무언가 숨기고 있다)`;break;case"fearful":a=`${i}${t.description} (위험한 일이 벌어지고 있다)`;break;default:a=`${i}${t.description}`}return a}calculateEmotionalImpact(t,e,s){const i={};switch(e.type){case"betrayal":i.trust=-.2,i.anger=s==="negative"?.3:.1;break;case"combat":i.fear=t.personality.courage<.5?.2:0;break;case"alliance":i.joy=s==="positive"?.1:0,i.fear=s==="fearful"?.1:-.05;break;case"death":i.fear=.15,i.despair=.1;break;case"plague":case"natural_disaster":i.fear=.3;break;case"war_declared":i.fear=t.personality.courage<.5?.4:.1;break}return s==="fearful"&&(i.fear=(i.fear||0)+.1),i}updateBelief(t,e,s,i,a=.1){v.updateBelief(t,v.beliefKey(e,s),i,a)}getBelief(t,e,s){const i=v.beliefKey(e,s);return t.beliefs.get(i)??.5}reconstructMemory(t,e){const s=t.memory.slice(-10);for(const i of s)i.interpretation.includes("좋은 의도")&&(e.includes("배신")||e.includes("거짓"))&&(i.interpretation=i.interpretation.replace("(좋은 의도였을 것이다)","(속았던 것이다!)"),i.emotionalImpact.anger=(i.emotionalImpact.anger||0)+.2)}getPerception(t,e){const s=this.world.relations.getRelation(t.id,e);if(!this.world.getCharacter(e))return"알 수 없음";const a=[];s.trust>.5?a.push("믿을 수 있는 사람"):s.trust<-.3&&a.push("신뢰할 수 없는 자"),s.fear>.5&&a.push("두려운 존재"),s.respect>.5?a.push("존경할 만한 인물"):s.respect<-.3&&a.push("경멸스러운 자");const r=this.getBelief(t,e,"honest");return r>.7?a.push("정직한 사람"):r<.3&&a.push("거짓말쟁이"),this.getBelief(t,e,"dangerous")>.7&&a.push("위험한 인물"),a.length===0?"특별한 인상 없음":a.join(", ")}shareInformation(t,e,s,i){const r=(this.world.relations.getRelation(e.id,t.id).trust+1)/2;let n=0,o="";switch(i){case"trustworthy":o="trustworthy",n=.5;break;case"dangerous":o="dangerous",n=.5;break;case"liar":o="honest",n=-.5;break;case"ally":o="ally",n=.5;break}this.updateBelief(e,s,o,n,r*.15)}}class z{constructor(t){c(this,"world");this.world=t}renderWorldState(t="novel"){const e=[],s=this.world.globalState;return e.push(this.renderTime(t)),s.warActive&&e.push(t==="novel"?"전쟁의 그림자가 온 땅을 뒤덮고 있다.":"[전쟁 중]"),s.plagueActive&&e.push(t==="novel"?"역병의 공포가 마을마다 퍼져 있다.":"[역병 발생]"),e.join(`
`)}renderTime(t){const{season:e,dayOfYear:s}=this.world.globalState,i={spring:"봄",summer:"여름",autumn:"가을",winter:"겨울"};switch(t){case"novel":return`${i[e]}의 ${s}일째 되는 날.`;case"formal":return`${i[e]} ${s}일`;case"report":return`[Day ${s}, ${e.toUpperCase()}]`;default:return`${i[e]} ${s}일`}}describeRelationChange(t,e,s,i){const a=this.world.getCharacter(t),r=this.world.getCharacter(e);if(!a||!r)return"";const n=[],o=r.name,h=i.trust-s.trust;h>.1?n.push(m([`${o}이(가) 당신을 더 신뢰하는 눈빛이다.`,`${o}의 태도가 한결 부드러워졌다.`,`${o}이(가) 당신에게 먼저 말을 건다.`,`${o}의 경계심이 누그러졌다.`])):h<-.1&&n.push(m([`${o}의 눈빛이 차가워졌다.`,`${o}이(가) 당신을 피하는 것 같다.`,`${o}의 말투가 딱딱해졌다.`,`${o}이(가) 당신을 경계한다.`]));const u=i.fear-s.fear;u>.1?n.push(m([`${o}이(가) 당신 앞에서 움츠러든다.`,`${o}의 목소리가 떨린다.`,`${o}이(가) 당신의 눈을 피한다.`])):u<-.1&&n.push(m([`${o}이(가) 더 이상 두려워하지 않는 것 같다.`,`${o}의 어깨가 펴졌다.`]));const d=i.respect-s.respect;return d>.1?n.push(m([`${o}의 눈에 존경이 담겼다.`,`${o}이(가) 당신을 다르게 보기 시작했다.`])):d<-.1&&n.push(m([`${o}이(가) 당신을 가볍게 여기는 것 같다.`,`${o}의 태도에서 경멸이 느껴진다.`])),n.length===0?"":n.join(" ")}describeOutcome(t,e,s){if(t){const i=[`${e}에 성공했다.`,`당신의 ${e}이(가) 효과가 있었다.`,`${s?s+"이(가) 반응했다.":"반응이 있었다."}`];return m(i)}else{const i=["아무 일도 일어나지 않았다.","상황이 변하지 않았다.","반응이 없었다.",`${s?s+"이(가) 무관심해 보인다.":"분위기가 어색하다."}`,"다른 누군가가 먼저 움직인 것 같다."];return m(i)}}describeCharacter(t,e="novel"){const s=this.world.getCharacter(t);if(!s)return"알 수 없는 인물";const i=[];s.title?i.push(`${s.title} ${s.name}`):i.push(s.name);const a=v.getDominantEmotion(s),r=this.getEmotionDescription(a,s.emotion[a]);r&&i.push(r);const n=v.getBehaviorTendency(s);return n.aggressive>.6?i.push(e==="novel"?"공격적인 기운이 느껴진다.":"[공격적]"):n.cautious>.6?i.push(e==="novel"?"조심스러운 태도를 보인다.":"[경계 중]"):n.cooperative>.6&&i.push(e==="novel"?"협조적인 모습이다.":"[우호적]"),i.join(" - ")}getEmotionDescription(t,e){return e<.3?"":m({trust:["믿음직스러운 눈빛","신뢰하는 표정"],fear:["두려움에 떨고 있다","공포에 질린 모습"],anger:["분노가 끓어오르고 있다","화가 난 표정"],joy:["밝은 표정","행복해 보인다"],despair:["절망에 빠져 있다","희망을 잃은 모습"]}[t]||[])||""}describeEvent(t,e="novel"){const s=t.participants.map(i=>{var a;return((a=this.world.getCharacter(i))==null?void 0:a.name)||"누군가"}).join(", ");return e==="novel"?this.describeEventNovel(t,s):e==="report"?`[${t.type.toUpperCase()}] ${t.description} (${s})`:t.description}describeEventNovel(t,e){switch(t.type){case"betrayal":return`어둠 속에서 칼이 번뜩였다. ${e}의 이야기가 세간에 퍼지기 시작했다.`;case"alliance":return`${e}이(가) 손을 맞잡았다. 새로운 동맹의 소식이 전해졌다.`;case"combat":return`칼날이 부딪히는 소리가 울려 퍼졌다. ${e}이(가) 충돌했다.`;case"trade":return`${e}이(가) 거래를 성사시켰다.`;case"death":return`${e}이(가) 숨을 거두었다. 세상이 한 사람을 잃었다.`;case"war_declared":return"전쟁의 북소리가 울려 퍼졌다. 평화의 시대가 끝났다.";case"plague":return"역병이 창궐하기 시작했다. 사람들이 두려움에 떨었다.";case"natural_disaster":return"자연이 분노했다. 재앙이 덮쳤다.";default:return t.description}}describeLocation(t,e="novel"){const s=this.world.getLocation(t);if(!s)return"알 수 없는 장소";const i=[];return i.push(s.name),s.stability<.3?i.push(e==="novel"?"불안한 기운이 감돈다.":"[불안정]"):s.stability>.8&&i.push(e==="novel"?"평화로운 분위기다.":"[안정]"),s.population>1e4?i.push(e==="novel"?"번화한 곳이다.":"[대도시]"):s.population<500&&i.push(e==="novel"?"조용한 곳이다.":"[소규모]"),i.join(" ")}formatChoices(t){return t.map((e,s)=>`${s+1}. ${e.text}
   └ ${e.context}`).join(`
`)}renderTurnSummary(t){const e=this.world.getCharacter(t);if(!e)return"";const s=[];s.push(this.renderTime("novel")),s.push(`당신은 ${this.describeLocation(e.location,"novel")}에 있다.`);const i=this.world.getRecentEvents(3);if(i.length>0){s.push(`
[최근 소식]`);for(const r of i)r.isPublic&&s.push(`- ${this.describeEvent(r,"novel")}`)}const a=this.world.getCharactersAt(e.location).filter(r=>r.id!==t);if(a.length>0){s.push(`
[주변 인물]`);for(const r of a.slice(0,3))s.push(`- ${this.describeCharacter(r.id,"novel")}`)}return s.join(`
`)}}const w={food:10,weapons:50,luxury:100,materials:20,medicine:30};class j{constructor(t){c(this,"world");c(this,"markets",new Map);c(this,"globalMoneySupply",1e5);c(this,"inflationRate",0);this.world=t,this.initializeMarkets()}initializeMarkets(){const t=this.world.getAllLocations();for(const e of t)(e.type==="city"||e.type==="village")&&this.markets.set(e.id,this.createMarket(e))}createMarket(t){const e=new Map,s=new Map,i=new Map,a=["food","weapons","luxury","materials","medicine"];for(const r of a){e.set(r,w[r]);const n=t.type==="city"?100:30,o=t.population/100;s.set(r,n*p(.8,1.2)),i.set(r,o*p(.8,1.2))}return{locationId:t.id,prices:e,supply:s,demand:i,tradeVolume:0}}update(){this.updatePrices(),this.updateSupplyDemand(),this.calculateInflation(),this.updateTradeRoutes()}updatePrices(){for(const e of this.markets.values())for(const[s,i]of Object.entries(w)){const a=s,r=e.supply.get(a)||1,o=(e.demand.get(a)||1)/Math.max(1,r),h=Math.pow(o,.3),u=1+this.inflationRate,d=i*h*u;e.prices.set(a,y(d,i*.5,i*3))}}updateSupplyDemand(){for(const t of this.markets.values()){const e=this.world.getLocation(t.locationId);if(e)for(const s of["food","weapons","luxury","materials","medicine"]){const i=this.calculateProduction(e,s),a=t.supply.get(s)||0;t.supply.set(s,a+i);const r=this.calculateDemandChange(e,s),n=t.demand.get(s)||0;t.demand.set(s,Math.max(0,n+r));const o=Math.min(a,n*.1);t.supply.set(s,Math.max(0,a-o))}}}calculateProduction(t,e){const s=t.resources/100,i={food:t.type==="village"?2:.5,weapons:t.type==="city"?1:.2,luxury:t.type==="city"?1:0,materials:1,medicine:.5};return s*i[e]*p(.8,1.2)}calculateDemandChange(t,e){const s=t.population/1e4,i=this.world.globalState.season;let a=1;return e==="food"&&(a=i==="winter"?1.5:1),e==="medicine"&&this.world.globalState.plagueActive&&(a=3),s*a*p(-.5,.5)}calculateInflation(){this.world.globalState.economyIndex<1?this.inflationRate=R(this.inflationRate,.1,.1):this.inflationRate=R(this.inflationRate,0,.1),this.inflationRate=y(this.inflationRate,-.1,.5)}updateTradeRoutes(){const t=this.world.getAllLocations();for(const e of t){const s=this.markets.get(e.id);if(s)for(const i of e.connectedTo){const a=this.markets.get(i);if(a)for(const r of["food","weapons","luxury","materials","medicine"]){const n=s.prices.get(r)||0,o=a.prices.get(r)||0;if(n>o*1.3){const u=a.supply.get(r)||0;u>5&&(a.supply.set(r,u-5),s.supply.set(r,(s.supply.get(r)||0)+5),s.tradeVolume+=5)}}}}}getPrice(t,e){var s;return((s=this.markets.get(t))==null?void 0:s.prices.get(e))||w[e]}buy(t,e,s){const i=this.markets.get(t);if(!i)return{success:!1,cost:0};const a=i.supply.get(e)||0;if(a<s)return{success:!1,cost:0};const n=(i.prices.get(e)||w[e])*s;return i.supply.set(e,a-s),i.demand.set(e,(i.demand.get(e)||0)+s*.5),{success:!0,cost:n}}sell(t,e,s){const i=this.markets.get(t);if(!i)return{success:!1,revenue:0};const r=(i.prices.get(e)||w[e])*s*.8;return i.supply.set(e,(i.supply.get(e)||0)+s),{success:!0,revenue:r}}getSummary(){const t=["food","weapons","luxury","materials","medicine"],e={};for(const s of t){let i=0,a=0;for(const r of this.markets.values())i+=r.prices.get(s)||0,a++;e[s]=a>0?i/a:w[s]}return{avgPrices:e,inflationRate:this.inflationRate,marketCount:this.markets.size}}}class V{constructor(t){c(this,"world");c(this,"ecosystems",new Map);this.world=t,this.initializeEcosystems()}initializeEcosystems(){const t=this.world.getAllLocations();for(const e of t)(e.type==="wilderness"||e.type==="village")&&this.ecosystems.set(e.id,this.createEcosystem(e))}createEcosystem(t){const e=new Map;return e.set("grass",{id:"grass",name:"풀",type:"plant",population:1e3,growthRate:.1,carryingCapacity:2e3}),e.set("deer",{id:"deer",name:"사슴",type:"prey",population:150,growthRate:.15,carryingCapacity:500}),e.set("wolf",{id:"wolf",name:"늑대",type:"predator",population:40,growthRate:.01,carryingCapacity:100,predationRate:.005,conversionRate:.15,mortalityRate:.02}),(t.type==="dungeon"||t.id==="dungeon")&&e.set("goblin",{id:"goblin",name:"고블린",type:"predator",population:30,growthRate:.02,carryingCapacity:100,predationRate:.005,conversionRate:.01,mortalityRate:.05}),{locationId:t.id,species:e,resources:t.resources,stability:t.stability}}update(){for(const t of this.ecosystems.values())this.updateEcosystem(t)}updateEcosystem(t){const e=this.world.globalState.season;let s=1;switch(e){case"spring":s=1.2;break;case"summer":s=1;break;case"autumn":s=.8;break;case"winter":s=.5;break}const i=Array.from(t.species.values()).filter(n=>n.type==="plant");for(const n of i)this.updateLogisticGrowth(n,s);const a=Array.from(t.species.values()).filter(n=>n.type==="prey"),r=Array.from(t.species.values()).filter(n=>n.type==="predator");for(const n of a)this.updatePreyPopulation(n,r,i);for(const n of r)this.updatePredatorPopulation(n,a);this.updateStability(t)}updateLogisticGrowth(t,e){const s=t.population,i=t.growthRate*e,a=t.carryingCapacity,r=i*s*(1-s/a);t.population=Math.max(0,s+r)}updatePreyPopulation(t,e,s){const i=t.population,a=s.reduce((h,u)=>h+u.population,0),r=Math.min(1,a/1e3),n=t.growthRate*i*r;let o=0;for(const h of e){const u=h.predationRate||0;o+=u*i*h.population}t.population=Math.max(0,i+n-o);for(const h of s)h.population=Math.max(0,h.population-i*.01)}updatePredatorPopulation(t,e){const s=t.population,i=t.predationRate||0,a=t.conversionRate||0,r=t.mortalityRate||.1;let n=0;for(const h of e)n+=a*i*h.population*s;const o=r*s;t.population=Math.max(0,s+n-o)}updateStability(t){const e=Array.from(t.species.values()),s=e.filter(a=>a.population<a.carryingCapacity*.1).length,i=e.filter(a=>a.population>a.carryingCapacity*.9).length;t.stability=y(1-(s+i)/(e.length||1)*.5,0,1)}hunt(t,e,s){const i=this.ecosystems.get(t);if(!i)return{success:!1,caught:0};const a=i.species.get(e);if(!a||a.type==="plant")return{success:!1,caught:0};const r=a.population,n=Math.min(s,r*.1);return n<1?{success:!1,caught:0}:(a.population-=n,{success:!0,caught:Math.floor(n)})}getEcosystemInfo(t){const e=this.ecosystems.get(t);return e?{species:Array.from(e.species.values()).map(s=>({name:s.name,population:Math.floor(s.population),type:s.type})),stability:e.stability}:null}getSummary(){let t=0;const e=[];for(const s of this.ecosystems.values()){t+=s.stability;for(const i of s.species.values())i.population<i.carryingCapacity*.1&&i.population>0&&(e.includes(i.name)||e.push(i.name))}return{totalLocations:this.ecosystems.size,avgStability:this.ecosystems.size>0?t/this.ecosystems.size:1,endangeredSpecies:e}}}const U={clear:{clear:.6,cloudy:.3,rain:.05,storm:.01,snow:.02,fog:.02},cloudy:{clear:.3,cloudy:.4,rain:.2,storm:.05,snow:.03,fog:.02},rain:{clear:.1,cloudy:.3,rain:.4,storm:.15,snow:.02,fog:.03},storm:{clear:.05,cloudy:.2,rain:.5,storm:.2,snow:.02,fog:.03},snow:{clear:.2,cloudy:.3,rain:.05,storm:.02,snow:.4,fog:.03},fog:{clear:.4,cloudy:.3,rain:.1,storm:.02,snow:.03,fog:.15}},Y={spring:{base:15,amplitude:10},summer:{base:25,amplitude:8},autumn:{base:12,amplitude:12},winter:{base:-2,amplitude:15}};class X{constructor(t){c(this,"world");c(this,"weatherByLocation",new Map);c(this,"globalWeather");this.world=t,this.globalWeather=this.createInitialWeather(),this.initializeLocations()}createInitialWeather(){return{type:"clear",temperature:20,humidity:.5,windSpeed:10,visibility:1,duration:3}}initializeLocations(){const t=this.world.getAllLocations();for(const e of t)this.weatherByLocation.set(e.id,{...this.globalWeather})}update(){this.updateGlobalWeather();for(const[t,e]of this.weatherByLocation)this.updateLocalWeather(t,e)}updateGlobalWeather(){this.globalWeather.duration--,this.globalWeather.duration<=0&&(this.globalWeather.type=this.getNextWeatherType(this.globalWeather.type),this.globalWeather.duration=Math.floor(p(2,6))),this.globalWeather.temperature=this.calculateTemperature(),this.adjustWeatherProperties(this.globalWeather)}getNextWeatherType(t){const e=U[t],s=this.world.globalState.season,i={...e};s==="winter"&&(i.snow=(i.snow||0)*3,i.rain=(i.rain||0)*.5),s==="summer"&&(i.snow=0,i.storm=(i.storm||0)*1.5);const a=Object.values(i).reduce((n,o)=>n+o,0);let r=Math.random()*a;for(const[n,o]of Object.entries(i))if(r-=o,r<=0)return n;return"clear"}calculateTemperature(){const t=this.world.globalState.season,e=this.world.globalState.dayOfYear,{base:s,amplitude:i}=Y[t],a=i*Math.sin(2*Math.PI*e/365),r=p(-5,5);let n=0;switch(this.globalWeather.type){case"rain":n=-3;break;case"storm":n=-5;break;case"snow":n=-10;break;case"clear":n=2;break}return s+a+r+n}adjustWeatherProperties(t){switch(t.type){case"clear":t.humidity=p(.3,.5),t.windSpeed=p(5,15),t.visibility=1;break;case"cloudy":t.humidity=p(.5,.7),t.windSpeed=p(10,20),t.visibility=.8;break;case"rain":t.humidity=p(.7,.9),t.windSpeed=p(15,30),t.visibility=.5;break;case"storm":t.humidity=p(.8,1),t.windSpeed=p(40,80),t.visibility=.2;break;case"snow":t.humidity=p(.6,.8),t.windSpeed=p(10,25),t.visibility=.4;break;case"fog":t.humidity=p(.9,1),t.windSpeed=p(0,5),t.visibility=.1;break}}updateLocalWeather(t,e){const s=this.world.getLocation(t);s&&(e.type=this.globalWeather.type,e.temperature=this.globalWeather.temperature+p(-3,3),e.humidity=y(this.globalWeather.humidity+p(-.1,.1),0,1),e.windSpeed=Math.max(0,this.globalWeather.windSpeed+p(-5,5)),e.visibility=y(this.globalWeather.visibility+p(-.1,.1),0,1),s.type==="dungeon"&&(e.type="clear",e.windSpeed=0,e.temperature=15))}getWeather(t){return this.weatherByLocation.get(t)||this.globalWeather}getEffects(t){const e=this.getWeather(t);let s=1,i=1,a=e.visibility,r=!1;switch(e.type){case"rain":s=.9,i=.8;break;case"storm":s=.7,i=.5,r=!0;break;case"snow":s=.85,i=.6,e.temperature<-10&&(r=!0);break;case"fog":s=.9,i=.7;break}return(e.temperature>35||e.temperature<-15)&&(r=!0),{combatModifier:s,travelModifier:i,visibilityModifier:a,healthRisk:r}}describe(t){const e=this.getWeather(t),s={clear:"맑은 하늘이 펼쳐져 있다.",cloudy:"구름이 하늘을 덮고 있다.",rain:"비가 내리고 있다.",storm:"폭풍이 몰아치고 있다.",snow:"눈이 내리고 있다.",fog:"짙은 안개가 끼어 있다."},i=e.temperature>30?"무더운":e.temperature>20?"따뜻한":e.temperature>10?"선선한":e.temperature>0?"쌀쌀한":"얼어붙을 듯 추운";return`${s[e.type]} ${i} 날씨다. (${e.temperature.toFixed(0)}°C)`}getSummary(){const t=[];let e=this.globalWeather.type;for(let s=0;s<3;s++)e=this.getNextWeatherType(e),t.push(e);return{globalType:this.globalWeather.type,avgTemperature:this.globalWeather.temperature,forecast:t}}}const K=[{id:"common_cold",name:"감기",transmissionRate:.3,recoveryRate:.5,mortalityRate:.001,incubationPeriod:1,immunityDuration:30},{id:"plague",name:"흑사병",transmissionRate:.5,recoveryRate:.1,mortalityRate:.3,incubationPeriod:3,immunityDuration:365},{id:"fever",name:"열병",transmissionRate:.7,recoveryRate:.1,mortalityRate:.02,incubationPeriod:1,immunityDuration:60}];class q{constructor(t){c(this,"world");c(this,"healthStatuses",new Map);c(this,"diseases",new Map);c(this,"activeOutbreaks",new Set);this.world=t,this.initializeDiseases(),this.initializeHealthStatuses()}initializeDiseases(){for(const t of K)this.diseases.set(t.id,t)}initializeHealthStatuses(){const t=this.world.getAllCharacters();for(const e of t)this.healthStatuses.set(e.id,{characterId:e.id,state:"susceptible",diseaseId:null,infectedTurn:0,exposedTurn:0,recoveredTurn:0})}update(){const t=this.world.time;for(const[e,s]of this.healthStatuses)this.updateIndividualHealth(e,s,t);this.spreadDisease(),this.updateGlobalPlagueState()}updateIndividualHealth(t,e,s){if(!e.diseaseId)return;const i=this.diseases.get(e.diseaseId);if(i)switch(e.state){case"exposed":s-e.exposedTurn>=i.incubationPeriod&&(e.state="infected",e.infectedTurn=s);break;case"infected":b(i.recoveryRate)?(e.state="recovered",e.recoveredTurn=s):b(i.mortalityRate)&&(e.state="dead",this.handleDeath(t));break;case"recovered":i.immunityDuration>0&&s-e.recoveredTurn>=i.immunityDuration&&(e.state="susceptible",e.diseaseId=null);break}}spreadDisease(){const t=this.world.getAllCharacters(),e=[];for(const s of t){const i=this.healthStatuses.get(s.id);if(!i||i.state!=="infected")continue;const a=this.diseases.get(i.diseaseId||"");if(!a)continue;const r=this.world.getCharactersAt(s.location);for(const n of r){if(n.id===s.id)continue;const o=this.healthStatuses.get(n.id);if(!o||o.state!=="susceptible")continue;const u=.5+(this.world.relations.getRelation(s.id,n.id).trust+1)*.25;b(a.transmissionRate*u)&&e.push({characterId:n.id,diseaseId:a.id})}}for(const{characterId:s,diseaseId:i}of e)this.infect(s,i)}infect(t,e){const s=this.healthStatuses.get(t);return!s||s.state!=="susceptible"?!1:(s.state="exposed",s.diseaseId=e,s.exposedTurn=this.world.time,this.activeOutbreaks.add(e),!0)}handleDeath(t){}updateGlobalPlagueState(){const t=this.getStats(),e=t.susceptible+t.exposed+t.infected+t.recovered,s=(t.exposed+t.infected)/Math.max(1,e);this.world.updateGlobalState({plagueActive:s>.1})}startOutbreak(t,e){if(!this.diseases.get(t))return!1;let i=e;if(!i){const r=this.world.getAllCharacters().filter(n=>{const o=this.healthStatuses.get(n.id);return(o==null?void 0:o.state)==="susceptible"});r.length>0&&(i=r[Math.floor(Math.random()*r.length)].id)}return i?this.infect(i,t):!1}treat(t,e=.5){const s=this.healthStatuses.get(t);return!s||s.state!=="infected"?!1:b(e)?(s.state="recovered",s.recoveredTurn=this.world.time,!0):!1}getHealthStatus(t){return this.healthStatuses.get(t)||null}getStats(){let t=0,e=0,s=0,i=0,a=0;for(const n of this.healthStatuses.values())switch(n.state){case"susceptible":t++;break;case"exposed":e++;break;case"infected":s++;break;case"recovered":i++;break;case"dead":a++;break}let r=0;for(const n of this.activeOutbreaks){const o=this.diseases.get(n);o&&(r=Math.max(r,o.transmissionRate/o.recoveryRate))}return{susceptible:t,exposed:e,infected:s,recovered:i,dead:a,r0:r}}describe(){const t=this.getStats(),e=t.susceptible+t.exposed+t.infected+t.recovered;if(t.infected===0&&t.exposed===0)return"현재 질병이 유행하고 있지 않다.";const s=((t.infected+t.exposed)/e*100).toFixed(1);let i="";return t.infected>e*.3?i="역병이 창궐하고 있다!":t.infected>e*.1?i="질병이 퍼지고 있다.":i="일부 지역에서 질병이 발생했다.",`${i} (감염률: ${s}%, 사망: ${t.dead}명)`}registerCharacter(t){this.healthStatuses.has(t)||this.healthStatuses.set(t,{characterId:t,state:"susceptible",diseaseId:null,infectedTurn:0,exposedTurn:0,recoveredTurn:0})}}class g{static initializePlayerStats(t){t.stats||(t.stats={maxHp:100,currentHp:100,maxMp:50,currentMp:50,attack:10,defense:5,speed:10,critRate:.05,critDamage:1.5}),t.level===void 0&&(t.level=1),t.experience===void 0&&(t.experience=0),t.expToNextLevel===void 0&&(t.expToNextLevel=this.getExpForLevel(2)),t.statPoints===void 0&&(t.statPoints=0),t.skillPoints===void 0&&(t.skillPoints=0),t.skills||(t.skills=[]),t.inventory||(t.inventory=[]),t.equipment||(t.equipment={})}static getExpForLevel(t){return Math.floor(this.BASE_EXP*Math.pow(t,this.EXP_EXPONENT))}static addExperience(t,e){return!t.experience||!t.expToNextLevel||!t.level?null:(t.experience+=e,t.experience>=t.expToNextLevel?this.levelUp(t):null)}static levelUp(t){if(!t.level||!t.stats)throw new Error("Character not initialized for leveling");const e=(t.experience||0)-(t.expToNextLevel||0);t.level++,t.expToNextLevel=this.getExpForLevel(t.level+1),t.experience=Math.max(0,e);const s={level:t.level,statPoints:this.STAT_POINTS_PER_LEVEL,skillPoints:this.SKILL_POINTS_PER_LEVEL,hpBonus:this.HP_PER_LEVEL,mpBonus:this.MP_PER_LEVEL};if(t.statPoints=(t.statPoints||0)+s.statPoints,t.skillPoints=(t.skillPoints||0)+s.skillPoints,t.stats.maxHp+=s.hpBonus,t.stats.maxMp+=s.mpBonus,t.stats.currentHp=t.stats.maxHp,t.stats.currentMp=t.stats.maxMp,t.experience>=t.expToNextLevel){const i=this.levelUp(t);s.statPoints+=i.statPoints,s.skillPoints+=i.skillPoints,s.hpBonus+=i.hpBonus,s.mpBonus+=i.mpBonus}return s}static distributeStat(t,e,s=1){if(!t.stats||!t.statPoints||t.statPoints<s)return!1;const a={attack:2,defense:2,speed:1,maxHp:10,maxMp:5,critRate:.01}[e]*s;switch(e){case"attack":t.stats.attack+=a;break;case"defense":t.stats.defense+=a;break;case"speed":t.stats.speed+=a;break;case"maxHp":t.stats.maxHp+=a;break;case"maxMp":t.stats.maxMp+=a;break;case"critRate":t.stats.critRate=y(t.stats.critRate+a,0,1);break}return t.statPoints-=s,!0}static learnSkill(t,e){return t.skills||(t.skills=[]),t.skills.some(s=>s.id===e.id)||(t.level||1)<e.requiredLevel||(t.skillPoints||0)<1?!1:(t.skills.push({...e}),t.skillPoints=(t.skillPoints||0)-1,!0)}static upgradeSkill(t,e){if(!t.skills||!t.skillPoints)return!1;const s=t.skills.find(i=>i.id===e);return!s||t.skillPoints<1?!1:(s.level++,t.skillPoints--,s.baseDamage&&(s.baseDamage=Math.floor(s.baseDamage*1.15)),s.healAmount&&(s.healAmount=Math.floor(s.healAmount*1.15)),!0)}static getLevelProgress(t){if(!t.experience||!t.expToNextLevel)return 0;const e=this.getExpForLevel(t.level||1),s=t.expToNextLevel-e,i=t.experience-e;return y(i/s,0,1)}static getEnemyExpReward(t,e){const s=this.getExpForLevel(t)*.3,i=t-e;let a=1;return i>0?a=1+i*.1:i<0&&(a=Math.max(.1,1+i*.15)),Math.floor(s*a)}}c(g,"BASE_EXP",100),c(g,"EXP_EXPONENT",1.5),c(g,"STAT_POINTS_PER_LEVEL",5),c(g,"SKILL_POINTS_PER_LEVEL",1),c(g,"HP_PER_LEVEL",10),c(g,"MP_PER_LEVEL",5);const $=[{id:"slime",name:"슬라임",level:1,hp:20,attack:5,defense:0,exp:5},{id:"wolf",name:"늑대",level:2,hp:40,attack:10,defense:2,exp:15},{id:"bandit",name:"산적",level:3,hp:60,attack:15,defense:5,exp:30},{id:"goblin",name:"고블린",level:1,hp:25,attack:8,defense:1,exp:8},{id:"skeleton",name:"스켈레톤",level:4,hp:50,attack:12,defense:3,exp:25}];class J{constructor(t,e){c(this,"world");c(this,"player");c(this,"king");c(this,"merchant");c(this,"feedbackLoop");c(this,"eventGenerator");c(this,"beliefSystem");c(this,"textRenderer");c(this,"choiceGen");c(this,"economy");c(this,"ecosystem");c(this,"weather");c(this,"disease");c(this,"currentTarget",null);c(this,"turnCount",0);c(this,"gameRunning",!0);c(this,"inCombat",!1);c(this,"currentCombat",null);c(this,"io");c(this,"saveSystem");this.io=t,this.saveSystem=e;const s=x();this.world=s.world,this.player=s.player,this.king=s.king,this.merchant=s.merchant}initGame(){const t=x();this.world=t.world,this.player=t.player,this.king=t.king,this.merchant=t.merchant,this.world.addLocation({id:"wilderness",name:"황야",type:"wilderness",resources:100,population:0,stability:.3,connectedTo:["village1"],dangerLevel:.6}),this.feedbackLoop=new W(this.world),this.eventGenerator=new H(this.world),this.beliefSystem=new G(this.world),this.textRenderer=new z(this.world),this.choiceGen=new O(this.world),this.economy=new j(this.world),this.ecosystem=new V(this.world),this.weather=new X(this.world),this.disease=new q(this.world),this.world.relations.updateRelation(this.player.id,this.merchant.id,{trust:.3}),this.world.relations.updateRelation(this.merchant.id,this.player.id,{trust:.2}),this.world.relations.updateRelation(this.king.id,this.merchant.id,{trust:.4}),g.initializePlayerStats(this.player),this.turnCount=0,this.currentTarget=null,this.inCombat=!1,this.currentCombat=null}getEmotionName(t){return{trust:"신뢰",fear:"공포",anger:"분노",joy:"기쁨",despair:"절망"}[t]||t}renderGameScreen(){this.io.clear(),this.io.printHeader(`MathWorld - 턴 ${this.turnCount}`);const t=this.weather.describe(this.player.location);this.io.print(`
${this.textRenderer.renderWorldState("novel")}`),this.io.print(t);const e=this.world.getLocation(this.player.location);this.io.print(`
📍 현재 위치: ${(e==null?void 0:e.name)||"알 수 없음"}`);const s=this.world.getCharactersAt(this.player.location).filter(r=>r.id!==this.player.id);s.length>0&&(this.io.printSection("주변 인물"),s.forEach((r,n)=>{const o=this.world.relations.getRelation(this.player.id,r.id),h=o.trust>.3?"😊":o.trust<-.3?"😠":"😐";this.io.print(`  ${n+1}. ${r.title||""} ${r.name} ${h}`)})),this.io.printSection("나의 상태");const i=v.getDominantEmotion(this.player);this.io.print(`  권력: ${this.player.power} | 자원: ${this.player.resources}`),this.io.print(`  주요 감정: ${this.getEmotionName(i)} (${(this.player.emotion[i]*100).toFixed(0)}%)`),this.player.stats&&(this.io.print(`  HP: ${this.player.stats.currentHp}/${this.player.stats.maxHp} | MP: ${this.player.stats.currentMp}/${this.player.stats.maxMp}`),this.io.print(`  레벨: ${this.player.level||1} (EXP: ${this.player.experience||0}/${this.player.expToNextLevel||100})`));const a=this.world.getRecentEvents(3);a.length>0&&(this.io.printSection("최근 소식"),a.forEach(r=>{r.isPublic&&this.io.print(`  • ${this.textRenderer.describeEvent(r,"novel")}`)}))}getMainMenuOptions(){const t=[];this.world.getCharactersAt(this.player.location).filter(r=>r.id!==this.player.id).forEach(r=>{t.push({text:`${r.name}에게 말 걸기`,action:`talk:${r.id}`})});const s=this.world.getLocation(this.player.location);s&&s.connectedTo.length>0&&s.connectedTo.forEach(r=>{const n=this.world.getLocation(r);n&&t.push({text:`${n.name}(으)로 이동`,action:`move:${r}`})}),t.push({text:"주변 관찰하기",action:"observe"});const i=this.world.getLocation(this.player.location);return(((i==null?void 0:i.dangerLevel)||0)>0||(i==null?void 0:i.type)==="wilderness"||(i==null?void 0:i.type)==="dungeon")&&t.push({text:"탐색하기 ⚔️",action:"explore"}),t.push({text:"상세 상태 보기",action:"status"}),t.push({text:"저장하기",action:"save"}),t.push({text:"불러오기",action:"load"}),t.push({text:"시간 보내기",action:"wait"}),t.push({text:"게임 종료",action:"quit"}),t}getInteractionChoices(t){const e=this.choiceGen.generateChoices(this.player,t.id);return e.push(this.choiceGen.getObserveChoice()),e.push(this.choiceGen.getSilenceChoice()),e}processTurn(){this.turnCount++,this.world.advanceTime(),this.economy.update(),this.ecosystem.update(),this.weather.update(),this.disease.update(),this.eventGenerator.generateNPCActions(),this.eventGenerator.generateEvents().forEach(s=>{s.isPublic&&this.io.print(`
📢 ${this.textRenderer.describeEvent(s,"novel")}`)}),this.feedbackLoop.checkThresholds().forEach(s=>{this.io.print(`
⚠️ [중대 사건] ${this.textRenderer.describeEvent(s,"novel")}`)})}async handleMainAction(t){const[e,s]=t.split(":");switch(e){case"talk":const i=this.world.getCharacter(s);return i&&(this.currentTarget=i),!1;case"move":const a=this.world.getLocation(s);return a&&(this.player.location=s,this.io.print(`
🚶 ${a.name}(으)로 이동했다.`),this.processTurn()),!0;case"observe":this.io.print(`
👁️ 주변을 살펴본다...`);const r=this.weather.getWeather(this.player.location);this.io.print(`  기온: ${r.temperature.toFixed(1)}°C`),this.io.print(`  습도: ${(r.humidity*100).toFixed(0)}%`),this.io.print(`  바람: ${r.windSpeed.toFixed(0)}km/h`);const n=this.ecosystem.getEcosystemInfo(this.player.location);return n&&(this.io.print(`
  [생태계]`),n.species.forEach(o=>{this.io.print(`    ${o.name}: ${o.population}마리`)})),!1;case"explore":return await this.handleExplore(),!0;case"status":return this.renderDetailedStatus(),!1;case"save":return await this.handleSave(),!1;case"load":return await this.handleLoad(),!1;case"wait":return this.io.print(`
⏳ 시간을 보낸다...`),this.processTurn(),!0;case"quit":return this.gameRunning=!1,this.io.print(`
게임을 종료합니다.`),!1}return!1}handleInteraction(t){if(this.currentTarget){this.io.print(`
💬 ${t.text}`);try{const e=this.currentTarget,s=this.world.relations.getRelation(this.player.id,e.id);this.feedbackLoop.applyChoice(t,this.player.id,e.id);const i=Math.random()>.3,a=this.textRenderer.describeOutcome(i,t.action.name,e.name);this.io.print(`→ ${a}`);const r=this.world.relations.getRelation(this.player.id,e.id),n=this.textRenderer.describeRelationChange(this.player.id,e.id,s,r);n&&this.io.print(`→ ${n}`),this.processTurn(),this.currentTarget=null}catch(e){this.io.print(`
⚠️ 오류 발생: ${e}`),this.currentTarget=null}}}renderDetailedStatus(){this.io.printHeader("상세 상태"),this.io.print(`
[플레이어]`),this.io.print(`  이름: ${this.player.name}`),this.io.print(`  권력: ${this.player.power}`),this.io.print(`  자원: ${this.player.resources}`),this.player.stats&&(this.io.print(`
[전투 능력치]`),this.io.print(`  HP: ${this.player.stats.currentHp}/${this.player.stats.maxHp}`),this.io.print(`  MP: ${this.player.stats.currentMp}/${this.player.stats.maxMp}`),this.io.print(`  공격력: ${this.player.stats.attack}`),this.io.print(`  방어력: ${this.player.stats.defense}`),this.io.print(`  속도: ${this.player.stats.speed}`)),this.io.print(`
[감정]`),Object.entries(this.player.emotion).forEach(([e,s])=>{const i="█".repeat(Math.floor(s*10))+"░".repeat(10-Math.floor(s*10));this.io.print(`  ${this.getEmotionName(e)}: [${i}] ${(s*100).toFixed(0)}%`)}),this.io.print(`
[관계]`),this.world.getAllCharacters().filter(e=>e.id!==this.player.id).forEach(e=>{const s=this.world.relations.getRelation(this.player.id,e.id),i="█".repeat(Math.max(0,Math.floor((s.trust+1)*5)))+"░".repeat(10-Math.max(0,Math.floor((s.trust+1)*5)));this.io.print(`  ${e.name}: [${i}] 신뢰 ${(s.trust*100).toFixed(0)}%`)})}async handleExplore(){this.io.print(`
🔍 주변을 탐색한다...`),Math.random()<.7?await this.runCombat():this.io.print(`
  주변에 아무것도 없다...`),this.processTurn()}async runCombat(){const t=this.world.getLocation(this.player.location),e=(t==null?void 0:t.dangerLevel)||.3,s=Math.floor(e*10)+1,i=$.filter(n=>n.level<=s),a=i[Math.floor(Math.random()*i.length)]||$[0],r={...a,maxHp:a.hp};for(this.io.print(`
⚔️ ${r.name}이(가) 나타났다!`);r.hp>0&&this.player.stats.currentHp>0;){this.io.print(`
[${r.name}] HP: ${r.hp}/${r.maxHp}`),this.io.print(`[${this.player.name}] HP: ${this.player.stats.currentHp}/${this.player.stats.maxHp}`);const n=await this.io.promptChoice(["⚔️ 공격","🛡️ 방어","🏃 도망"]);if(n===0){const u=Math.max(1,(this.player.stats.attack||10)-(r.defense||0)),d=Math.random()<(this.player.stats.critRate||.05),E=d?Math.floor(u*1.5):u;r.hp=Math.max(0,r.hp-E),this.io.print(`⚔️ ${this.player.name}의 공격! ${E} 피해${d?"(치명타!)":""}`)}else if(n===1)this.io.print("🛡️ 방어 태세를 취했습니다.");else if(n===2){if(Math.random()<.5){this.io.print("🏃 도망쳤습니다!");return}this.io.print("❌ 도망에 실패했습니다!")}if(r.hp<=0)break;const o=n===1,h=Math.max(1,(r.attack||5)-this.player.stats.defense*(o?2:1));if(this.player.stats.currentHp=Math.max(0,this.player.stats.currentHp-h),this.io.print(`💥 ${r.name}의 공격! ${h} 피해`),this.player.stats.currentHp<=0){this.io.print("💀 패배했습니다..."),this.player.stats.currentHp=Math.floor(this.player.stats.maxHp*.3),this.player.location="village1",this.io.print("...마을에서 깨어났습니다.");return}}if(r.hp<=0){this.io.print(`🎉 승리! ${r.name}을(를) 처치했습니다.`);const n=r.exp||10;this.io.print(`💰 ${n} 경험치 획득`),await this.handleLevelUp(n)}}async handleLevelUp(t){const e=g.addExperience(this.player,t);if(e)for(this.io.print(`
🎉 레벨 업! (Lv.${e.level})`),this.io.print(`💪 사용할 수 있는 스탯 포인트: ${e.statPoints}`);this.player.statPoints>0;){this.io.print(`
남은 포인트: ${this.player.statPoints}`);const s=await this.io.promptChoice(["공격력 (+2)","방어력 (+2)","최대 HP (+10)","최대 MP (+5)","속도 (+2)","완료"]),i={0:"attack",1:"defense",2:"maxHp",3:"maxMp",4:"speed"};if(s===5)break;i[s]&&(g.distributeStat(this.player,i[s]),this.io.print(`✅ ${i[s]} 증가!`))}}async handleSave(){this.io.print(`
💾 게임 저장`);const e=(await this.io.prompt("저장 슬롯 이름 (기본: slot1): ")).trim()||"slot1";this.saveSystem.saveGame(e,this.turnCount,this.player,this.world)?this.io.print(`✅ "${e}" 슬롯에 저장 완료!`):this.io.print("❌ 저장 실패")}async handleLoad(){this.io.print(`
📂 저장 목록`);const t=this.saveSystem.listSaves();if(t.length===0){this.io.print("  저장된 게임이 없습니다.");return}const e=t.map((i,a)=>`[${i.slotName}] ${i.playerName} - 턴 ${i.turnCount} (${this.saveSystem.formatTimestamp(i.timestamp)})`);e.push("취소");const s=await this.io.promptChoice(e);if(s>=0&&s<t.length){const i=this.saveSystem.loadGame(t[s].slotName);i?(this.saveSystem.restoreToWorld(i,this.world),Object.assign(this.player,i.player),this.turnCount=i.turnCount,this.io.print(`✅ "${t[s].slotName}" 불러오기 완료!`)):this.io.print("❌ 불러오기 실패")}}async run(){for(this.io.clear(),this.io.printHeader("MathWorld - 텍스트 소설형 RPG"),this.io.print(`
수학적 알고리즘으로 구동되는 살아있는 세계에 오신 것을 환영합니다.`),this.io.print(`당신의 선택이 세계를 바꿉니다.
`),await this.io.prompt("Enter를 눌러 시작하세요..."),this.initGame();this.gameRunning;)if(this.currentTarget){this.renderGameScreen(),this.io.printSection(`${this.currentTarget.name}과(와)의 상호작용`);const t=this.getInteractionChoices(this.currentTarget),e=t.map(i=>i.text);e.push("돌아가기"),t.forEach((i,a)=>{this.io.print(`  ${a+1}. ${i.text}`),this.io.print(`     └ ${i.context}`)});const s=await this.io.promptChoice(e);s===e.length-1?this.currentTarget=null:s>=0&&s<t.length&&(this.handleInteraction(t[s]),await this.io.prompt(`
Enter를 눌러 계속...`))}else{this.renderGameScreen(),this.io.printSection("행동 선택");const t=this.getMainMenuOptions(),e=t.map(i=>i.text);t.forEach((i,a)=>{this.io.print(`  ${a+1}. ${i.text}`)});const s=await this.io.promptChoice(e);s>=0&&s<t.length&&(await this.handleMainAction(t[s].action)||t[s].action==="observe"||t[s].action==="status")&&await this.io.prompt(`
Enter를 눌러 계속...`)}this.io.print(`
게임을 플레이해주셔서 감사합니다!`)}isRunning(){return this.gameRunning}getCurrentTarget(){return this.currentTarget}getPlayer(){return this.player}getWorld(){return this.world}getTurnCount(){return this.turnCount}}class Q{constructor(){c(this,"outputElement");c(this,"choicesElement");c(this,"statusElement");c(this,"pendingPromise",null);c(this,"pendingChoicePromise",null);this.outputElement=document.getElementById("game-output"),this.choicesElement=document.getElementById("game-choices"),this.statusElement=document.getElementById("game-status"),this.setupAutoScroll()}setupAutoScroll(){new MutationObserver(()=>{this.scrollToBottom()}).observe(this.outputElement,{childList:!0,subtree:!0})}scrollToBottom(){this.outputElement.scrollTop=this.outputElement.scrollHeight}print(t){const e=document.createElement("div");e.className="log-line",e.textContent=t,this.outputElement.appendChild(e)}clear(){this.outputElement.innerHTML=""}prompt(t){return new Promise(e=>{this.print(t),this.choicesElement.innerHTML="";const s=document.createElement("button");s.className="choice-button continue-button",s.textContent="계속 ▶",s.onclick=()=>{this.choicesElement.innerHTML="",e("")},this.choicesElement.appendChild(s)})}promptChoice(t){return new Promise(e=>{this.choicesElement.innerHTML="",t.forEach((s,i)=>{const a=document.createElement("button");a.className="choice-button",a.innerHTML=`<span class="choice-number">${i+1}</span> ${s}`,a.onclick=()=>{this.choicesElement.innerHTML="",e(i)},this.choicesElement.appendChild(a)})})}printHeader(t){const e=document.createElement("div");e.className="log-header",e.innerHTML=`
            <div class="header-line">═══════════════════════════════════════</div>
            <div class="header-title">${t}</div>
            <div class="header-line">═══════════════════════════════════════</div>
        `,this.outputElement.appendChild(e)}printSection(t){const e=document.createElement("div");e.className="log-section",e.textContent=`【 ${t} 】`,this.outputElement.appendChild(e)}printLine(t="─",e=40){const s=document.createElement("div");s.className="log-divider",s.textContent=t.repeat(e),this.outputElement.appendChild(s)}updateStatus(t,e,s,i,a){this.statusElement.innerHTML=`
            <div class="status-location">📍 ${a}</div>
            <div class="status-bars">
                <div class="hp-bar">
                    <span class="bar-label">HP</span>
                    <div class="bar-container">
                        <div class="bar-fill hp-fill" style="width: ${t/e*100}%"></div>
                    </div>
                    <span class="bar-value">${t}/${e}</span>
                </div>
                <div class="mp-bar">
                    <span class="bar-label">MP</span>
                    <div class="bar-container">
                        <div class="bar-fill mp-fill" style="width: ${s/i*100}%"></div>
                    </div>
                    <span class="bar-value">${s}/${i}</span>
                </div>
            </div>
        `}}class Z{constructor(){c(this,"SAVE_PREFIX","mathworld_save_");c(this,"SAVE_LIST_KEY","mathworld_saves")}saveGame(t,e,s,i){try{const a={version:"1.0.0",timestamp:new Date().toISOString(),turnCount:e,player:this.serializePlayer(s),worldState:this.serializeWorld(i)};return localStorage.setItem(this.SAVE_PREFIX+t,JSON.stringify(a)),this.updateSaveList(t,s.name,e,a.timestamp),!0}catch(a){return console.error("저장 실패:",a),!1}}loadGame(t){try{const e=localStorage.getItem(this.SAVE_PREFIX+t);return e?JSON.parse(e):null}catch(e){return console.error("불러오기 실패:",e),null}}listSaves(){try{const t=localStorage.getItem(this.SAVE_LIST_KEY);return t?JSON.parse(t):[]}catch{return[]}}deleteSave(t){try{localStorage.removeItem(this.SAVE_PREFIX+t);const e=this.listSaves().filter(s=>s.slotName!==t);return localStorage.setItem(this.SAVE_LIST_KEY,JSON.stringify(e)),!0}catch{return!1}}formatTimestamp(t){try{const e=new Date(t);return`${e.getMonth()+1}/${e.getDate()} ${e.getHours()}:${String(e.getMinutes()).padStart(2,"0")}`}catch{return t}}restoreToWorld(t,e){t.worldState&&(t.worldState.time!==void 0&&(e.time=t.worldState.time),t.worldState.globalState&&Object.assign(e.globalState,t.worldState.globalState))}serializePlayer(t){return{id:t.id,name:t.name,title:t.title,location:t.location,power:t.power,resources:t.resources,personality:{...t.personality},emotion:{...t.emotion},stats:t.stats?{...t.stats}:void 0,level:t.level,experience:t.experience,expToNextLevel:t.expToNextLevel,statPoints:t.statPoints}}serializeWorld(t){return{time:t.time,globalState:{...t.globalState}}}updateSaveList(t,e,s,i){const a=this.listSaves().filter(r=>r.slotName!==t);a.unshift({slotName:t,playerName:e,turnCount:s,timestamp:i}),localStorage.setItem(this.SAVE_LIST_KEY,JSON.stringify(a))}}async function tt(){const l=new Q,t=new Z,e=new J(l,t);try{await e.run()}catch(s){console.error("게임 오류:",s),l.print(`
⚠️ 오류 발생: ${s}`)}}document.addEventListener("DOMContentLoaded",()=>{const l=document.getElementById("start-button"),t=document.getElementById("start-screen"),e=document.getElementById("game-screen");l&&l.addEventListener("click",()=>{t&&t.classList.add("hidden"),e&&e.classList.remove("hidden"),tt()})})});export default et();
